#!/usr/bin/env python3

# pyhole - a clone of the Pi-hole DNS adblocker, written in Python.
# pyhole  (c) 2016 by ryt51V
# Pi-Hole (c) 2015, 2016 by Jacob Salmela

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# For running system commands and setting permissions.
import os
# For getting the command line arguments we were run with.
import sys
# For named tuples
from collections import namedtuple
# For ncurses dialogs
# http://pythondialog.sourceforge.net/doc/Dialog_class_overview.html
# http://pythondialog.sourceforge.net/doc/widgets.html
from dialog import Dialog
# For parsing the config file
import configparser
# For managing apt packages
# https://apt.alioth.debian.org/python-apt-doc/library/apt.cache.html
# https://apt.alioth.debian.org/python-apt-doc/library/apt.package.html
import apt
# For looking up interfaces and IP addresses.
import netifaces
# For file operations including ownership
import shutil
# Our very own module!
from pyhole import pyhole


# If not root, rerun as root with sudo.
if os.geteuid() != 0:
    print("Rerunning as root with sudo...")
    os.execvp("sudo", ["sudo"] + sys.argv)
#end if os.geteuid() != 0:

########################
###     Variables    ###
########################

# Define the web server named tuple
w = namedtuple('webserver',
               'name, package_name, install_description'
              )

# Define the web server packages and their properties.
web_servers = [
    w('lighttpd', 'lighttpd', 'Install pyhole and pyhole-admin files and lighttpd hosts.'),
    w('apache'  , 'apache2' , 'Install pyhole and pyhole-admin files and apache vhosts.' ),
    w('Manual'  , None      , 'Install pyhole and pyhole-admin files only.'),
]

# Define the DNS servers named tuple

dp = namedtuple('dns_provider',
                          'name, servers'
                          )
                
# Define choices of DNS servers.

dns_providers = [
    dp('Google' , [ '8.8.8.8'       , '8.8.4.4'       ] ),
    dp('OpenDNS', [ '208.67.222.222', '208.67.220.220'] ),
    dp('Level3' , [ '4.2.2.1'       , '4.2.2.2'       ] ),
    dp('Norton' , [ '199.85.126.10' , '199.85.127.10' ] ),
    dp('Comodo' , [ '8.26.56.26'    , '8.20.247.20'   ] )
]

########################
###   Configuration  ###
########################

# Create a dialog object we will use for all ncurses dialogs.
d = Dialog(autowidgetsize = True)
d.set_background_title("pyhole-config")

# Initialise our apt cache so we can check if packages are installed.
apt_cache = apt.Cache()

########################
##  Helper Functions  ##
########################

def cancel_pressed():
    """Gracefully exit the script.  To be run whenever a user chooses cancel."""
    print("Cancel button pressed.  Exiting...")
    sys.exit()
#end def cancel_pressed():

def package_is_installed(package : str):
    """Return whether a package is installed."""
    if package in apt_cache:
        # Package is in the cache - not neccesarily installed
        return apt_cache[package].is_installed
    else:
        # Package is not in the cache - can't be installed.
        return False
    #end else
#end def package_is_installed(package):

def package_install(package : str):
    """Install a package"""
    if not package in apt_cache:
        print("Package {0} is not in the apt cache.".format(package) )
        raise
    #end if not package in apt_cache:
    
    if apt_cache[package].is_installed:
        print("Package {0} is already installed.".format(package) )
        raise
    #end if apt_cache[package].is_installed:
    
    apt_cache[package].mark_install
    apt_cache.commit()
    
    # Reload the changes to apt-cache
    apt_cache.open()
    
#end def package_install(package : str):

def copy_and_replace(src, dst, replacements):
    
    # Replacements must be a dict like, for example:
    # replacements = {
        # '@DNSSERVERS@' : DNSSERVERS,
        # '@INT@'        : interface
    # }
    
    with open(src) as infile, open (dst, 'w') as outfile:
        for line in infile:
            for src, target in replacements.items():
                line = line.replace(src, target)
            #end for src, target in replacements.items():
            outfile.write(line)
        #end for line in infile:
    #end with
#end def copy_and_replace(src, dst, replacements):

########################
##  Gather Functions  ##
########################

def show_welcome_message():
    """Display any welcome messages."""
    message = "This program will configure your pyhole."
    d.msgbox(message)
#end def show_welcome_message:

def choose_web_server():
    """Allow the user to choose the web server they want."""
    
    # Find out which of our choices are available.
    choices = []
    web_servers_installed = []
    
    for ws in web_servers:
        # The item for the "choice" list that we will pass to the menu dialog.
        choice = ( ws.name, ws.install_description )
        
        if ws.name == "Manual":
            # Manual is always an option.
            choices.append(choice)
        elif package_is_installed(ws.package_name):
            # Web servers are only an option if their package is installed.
            choices.append(choice)
            web_servers_installed.append(ws.package_name)
        #end if package_is_installed(ws['package_name']):
    #end for ws in web_servers:
    
    web_server_msgbox = "pyhole requires a web server with two virtual hosts - one to serve an empty page that replaces ads, and one for the admin web interface to view stats and whitelist or blacklist ad servers.\n\n"
    
    web_server_msgbox += "pyhole can automatically configure certain web servers for you if they are already installed.  Alternatively, pyhole can just install the web server files for you to use with a web server you configure manually yourself.\n\nThe web servers supported for automatic configuration are as follows:\n\n"
    
    # Display one web server on each line, except Manual of course.
    for ws in web_servers:
        if ws.name != 'Manual': web_server_msgbox += "{0}\n".format(ws.package_name)
    #end for w in web_servers:
    
    d.msgbox(web_server_msgbox)
    
    if len(web_servers_installed) == 0:
        web_server_message = "No web servers supported for automatic configuration appear to be installed.  If you wish for pyhole to configure one for you then please cancel pyhole-config and install one of the supported web servers above.  Otherwise you may proceed with manual configuration.\n\nIf you are unsure, cancel this config and run the following before continuing:\n\nsudo apt-get install lighttpd"
    else:
        web_server_message = "Web servers supported for automatic configuration that are already installed web servers appear below.  Please choose an option.\n\nIf you are unsure, choose {0}.".format(choices[0][0])
    #end else:
    
    button, answer = d.menu(web_server_message, choices=choices)
    
    if button == d.CANCEL: cancel_pressed()
    
    return answer
    
#end def choose_web_server():

def choose_web_roots():
    """Allow the user to choose web roots."""
    web_root_message = "Choose where you would like pyhole to install the virtual hosts.\n\nIf you are unsure, leave these as the default."
    
    elements = [
        ("pyhole"      , 2, 2, "/var/www/pyhole"      , 2, 20, 50, 255),
        ("pyhole-admin", 4, 2, "/var/www/pyhole-admin", 4, 20, 50, 255)
    ]
    
    button, answer = d.form(web_root_message, elements = elements, form_height = 5)
    
    if button == d.CANCEL: cancel_pressed()
    
    return answer
    
#end def chooce_web_roots():

def choose_webserver_password():
    """Allow the user to choose a password for the web interface"""
    
    base_message1 = """When accessing the Pi-hole admin interface, you will need to log on with the username 'pyhole' and a password of your choosing.  \n\nPlease enter a password to secure your pyhole web interface."""
    
    message1 = base_message1
    
    message2 = """Please re-enter your password to confirm"""
    
    password_validated = False
    
    while password_validated == False:
        button, answer1 = d.passwordbox(message1)
        if button == d.CANCEL: cancel_pressed()
        
        button, answer2 = d.passwordbox(message2)
        if button == d.CANCEL: cancel_pressed()
        
        error_message1 = ""
        
        if answer1 != answer2:
            error_message1 = """Passwords did not match.\n"""
        elif answer1 == "":
            error_message1 = """You cannot have an empty password.\n\nWe're not performing any other password validation here - make it something simple if you want, just not blank!\n"""
        else:
            password_validated = True
        #end else
        
        message1 = error_message1 + "\n" + base_message1
        
    #end while password_validated == False:
    
    return answer1
#end def choose_webserver_password():

def choose_interface():
    """Allow the user to choose their network interface."""
    interfaces = netifaces.interfaces()
    
    choices = []
    for i in interfaces:
        choice = ( i, "", False )
        if i != "lo":
            choices.append(choice)
        #end if i != "lo":
    #end for i in interfaces:
    
    message = "Please select a network interface.\n\nIf you are unsure, eth0 is almost always the best choice if you are using a wired connection."
    
    answer = None
    
    while not answer:
        button, answer = d.radiolist(message, choices=choices)
        
        if button == d.CANCEL: cancel_pressed()
    #end while not answer:
    
    return answer
    
#end def choose_interface():

def choose_ipv4_ipv6():
    """Allow the user to choose IPv4 and/or IPv6."""
    # Our choice of protocols.
    choices = [
        ('IPv4', "", True ),
        ('IPv6', "", False)
    ]
    
    message = 'Please select at least one protocol.\n\nIf you are unsure, leave these as they are.'
    
    answer = None
    
    while not answer:
        button, answer = d.checklist(text = message, choices=choices)
        
        if button == d.CANCEL: cancel_pressed()
    #end while not answer:
    
    return answer
    
#end def choose_ipv4_ipv6():

def choose_ipv4_address(interface: str):
    """Allow the user to choose their IPv4 address on the provided interface."""
    # Get the IPv4 addresses on the given interface
    # AF_INET represents IPv4
    addrs = netifaces.ifaddresses(interface)[netifaces.AF_INET]
    
    # Get all of our choices
    # We index them as we want to return the full addr object.
    choices = []
    i = 0
    for a in addrs:
        description = "addr {0[addr]}  netmask {0[netmask]}  broadcast {0[broadcast]}".format(a)
        # The first argument needs to be a string; it won't work with int.
        choices.append( ( str(i), description, False ) )
        i += 1
    #end for a in addr:
    
    message = "Please select an IPv4 address on interface {0}.\n\nIf you are unsure, choose the first one.".format(interface)
    
    answer = None
    while not answer:
        button, answer = d.radiolist(text = message, choices=choices)
        if button == d.CANCEL: cancel_pressed()
    #end while not answer:
    
    # Get the object represented by the chosen list item.
    return addrs[int(answer)]
    
#def choose_ipv4_address():

def choose_ipv6_address(interface: str):
    """Allow the user to choose their IPv6 address on the provided interface."""
    # Get the IPv6 addresses on the given interface
    # AF_INET6 represents IPv6
    addrs = netifaces.ifaddresses(interface)[netifaces.AF_INET6]
    
    # Get all of our choices
    # We index them as we want to return the full addr object.
    choices = []
    i = 0
    for a in addrs:
        description = "addr {0[addr]}  netmask {0[netmask]}".format(a)
        # The first argument needs to be a string; it won't work with int.
        choices.append( ( str(i), description, False ) )
        i += 1
    #end for a in addr:
    
    message = "Please select an IPv6 address on interface {0}.\n\n".format(interface)
    
    message += "If you wish to use IPv6, we assume you know what you are doing - this should be a static address.  We won't perform any further checks or offer to reconfigure it for you."
    
    answer = None
    while not answer:
        button, answer = d.radiolist(text = message, choices=choices)
        if button == d.CANCEL: cancel_pressed()
    #end while not answer:
    
    # Get the object represented by the chosen list item.
    return addrs[int(answer)]
    
#def choose_ipv6_address():

def choose_ipv4_reconfigure(interface : str, ipv4_address):
    """Check whether the IPv4 address is static."""
    
    # There does not seem to be a decent way to tell whether or not an IPv4 address is static.
    # We will look in the file /etc/network/interfaces for the phrases below and judge.
    #   'iface <interface name> inet static'
    #   'iface <interface name> inet dhcp'
    # Yes this could fail for many reasons including use of /etc/network/interfaces, so we won't
    # make hard decisions based on this.
    
    ipv4_address_type = 'unknown'
    
    static_search_string    = 'iface {0} inet static'.format(interface)
    dynamic_search_string   = 'iface {0} inet dhcp'.format(interface)
    
    with open('/etc/network/interfaces', 'r') as f:
        interfaces_file = f.read()
    #end with open('/etc/network/interfaces', 'r') as f:
    
    if static_search_string in interfaces_file:
        ipv4_address_type = 'static'
    elif dynamic_search_string in interfaces_file:
        ipv4_address_type = 'dynamic'
    #end elif dynamic_search_string in interfaces_file:
    
    message = ""
    
    if ipv4_address_type == 'static':
        message += "It looks like your IPv4 address {0[addr]} on interface {1} is already static, which is good.  (This may be incorrect though.)\n\n".format(ipv4_address, interface)
    elif ipv4_address_type == 'dynamic':
        message += "It looks like your IPv4 address {0[addr]} on interface {1} is dynamic.  (This may be incorrect though.)  You need to have a static IP.\n\n".format(ipv4_address, interface)
    else:
        message += "We're unable to tell whether your address {0[addr]} on interface {1} is dynamic or static.\n\n".format(ipv4_address, interface)
    #end else:
    
    message += "Choose whether to keep your existing IPv4 address settings or reconfigure them."
    
    if ipv4_address_type == 'static':
        message += "If you are unsure, choose to keep your current network settings."
    else:
        message += "If you are unsure, choose to configure a static IPv4 address."
    #end else:
    
    choices = [
        ( "Keep"  , "Keep my IPv4 address settings as is." ),
        ( "Configure", "Configure a static IPv4 address for me." )
    ]
    
    button, answer = d.menu(message, choices=choices)
    
    if button == d.CANCEL: cancel_pressed()
    
    return answer
    
#end def choose_ipv4_reconfigure(interface : str, ipv4_address):

def choose_ipv4_new_static(interface: str, ipv4_address):
    """Allow the user to choose their desired static IPv4 settings."""
    gateway = netifaces.gateways()['default'][netifaces.AF_INET]
    
    elements = [
        ("address", 2, 2, ipv4_address['addr']   , 2, 15, 25, 25),
        ("netmask", 4, 2, ipv4_address['netmask'], 4, 15, 25, 25),
        ("gateway", 6, 2, gateway[0]             , 6, 15, 25, 25)
    ]
    
    base_message = "Please enter your desired static IPv4 settings.\n\n"
    
    base_message += "If you are unsure, you can leave them as is.  It is possible your router could still try to assign this IPv4 address to a device, which would cause a conflict, but in most cases the router is smart enough to not do that and the device is smart enough not to accept the IP.  If you are worried, set the address to one outside your DHCP pool and/or make a DHCP reservation for the IPv4 address you set here."
    
    message = base_message
    validated = False
    
    
    while validated == False:
        button, answer = d.form(message, elements = elements, form_height = 7)
        if button == d.CANCEL: cancel_pressed()
        
        error_message = ""
        
        validated = True
        if not pyhole.valid_ip(answer[0]):
            validated = False
            error_message += "Address is not valid: {0}\n".format(answer[0])
        #end if not pyhole.valid_ip(answer[0]):
        
        if not pyhole.valid_ip(answer[1]):
            validated = False
            error_message += "Netmask is not valid: {0}\n".format(answer[1])
        #end if not pyhole.valid_ip(answer[1]):
        
        if not pyhole.valid_ip(answer[2]):
            validated = False
            error_message += "Gateway is not valid: {0}\n".format(answer[2])
        #end if not pyhole.valid_ip(answer[2]):
        
        message = error_message + "\n" + base_message
        
    #end while validated == False:
    
    return answer
    
#end def choose_ipv4_new_static(interface: str, ipv4_address):

def set_ipv4_static(interface : str, ipv4address):
    
    # Are we using dhcpcd?
    # Raspbian uses dhcpcd by default.  Debian doesn't.
    pass
    
#end def set_ipv4_static(interface : str, ipv4address):

def choose_dns_custom_servers(quantity=2):
    """Allow the user to choose custom DNS servers."""
    elements = []
    
    for x in range( 0 , quantity ):
        # Rows are 2, 4, 6, 8, etc. to allow some nice spacing.
        row = 2*(x+1)
        row1_col1_msg = "Server {0} IP Address".format(x+1)
        
        elements.append( ( row1_col1_msg , row, 2  , "" , row , 25 , 20 , 20 ) )
        elements.append( ( "Port"        , row, 48 , "" , row , 54 , 7  , 5  ) )
    #end for x in range( 0 , quantity ):
    
    base_message = "Enter the details of your DNS provider.  You can enter up to {0} servers on this screen.\n\n".format(quantity)
    
    base_message += "Port is optional and should only be specified if the provider of your DNS server explicitly says to use it.  If you are unsure then leave the Port fields blank."
    
    # Form height is 2*number of rows + 1 to allow nice spacing.
    form_height = 2*quantity + 1
    
    message = base_message
    
    servers_validated = False
    
    while servers_validated == False:
        button, answer = d.form(message, elements = elements, form_height = form_height)
        
        if button == d.CANCEL: cancel_pressed()
        
        servers = []
        servers_validated = True
        error_message = ""
        
        for x in range( 0 , quantity ):
            # Generate our dns_provider object from the answers
            # answer[2*x] is the IP address and answer[2*x+1] is the port.
            # e.g.
            #   x=0     IP: answer[0]   Port: answer[1]
            #   x=1     IP: answer[2]   Port: answer[3]
            #   x=2     IP: answer[4]   Port: answer[5]
            #   etc.
            # If the custom port is specified, add it after a # after the IP.
            # This is dnsmasq.conf syntax.
            
            ip   = answer[2*x]
            port = answer[2*x+1]
            
            
            # If a server was entered...
            if ip:
                
                # Check if the IP is valid.
                if not pyhole.valid_ip(ip): 
                    # If not, set servers_validated to false so we return back to the menu.
                    servers_validated = False
                    error_message += "Server {0} IP address is not valid: {1}\n".format( x+1, ip )
                #end if not pyhole.valid_ip(ip):
                
                if port:
                    # Similarly, check if the port is valid.
                    if not pyhole.valid_port(port): 
                        servers_validated = False
                        error_message += "Server {0} port is not valid: {1}\n".format( x+1, port )
                    #end if not pyhole.valid_port(port):
                    server = "{0}#{1}".format(ip, port)
                else:
                    server = ip
                #end else:
                
                # Add it to our list.
                servers.append(server)
            #end if answer[2*x]:
        #end for x in range( 0 , quantity ):
        
        # We must have at least one server!
        if len(servers) == 0:
            servers_validated = False
            error_message += "You must enter at least one server.\n"
        #end if len(servers) == 0:
        
        # The message we will display on next run of the menu.
        message = error_message + "\n" + base_message
        
        if servers_validated: dns_provider = dp("Custom", servers )
        
    #end while servers_validated = False:
    
    return dns_provider
    
#end def choose_dns_custom_servers(quantity=2):

def choose_dns_provider():
    """Allow the user to choose their DNS provider, or specify their own."""
    
    choices = []
    for dns in dns_providers:
        choice = ( dns.name, "" )
        choices.append(choice)
    #end for dns in dns_providers:
    
    custom = ( "Custom", "Set your own DNS servers." )
    choices.append(custom)
    
    message = "pyhole needs to use an upstream DNS provider to resolve normal (non-ad) domain names.  Please choose a DNS provider.\n\nIf you are unsure, choose Google DNS."
    
    button, answer = d.menu(message, choices=choices)
    
    if button == d.CANCEL: cancel_pressed()
    
    if (answer == "Custom"):
        # If they have chosen custom, move on to asking them for their custom server.
        answer_provider = choose_dns_custom_servers(3)
    else:
        # If they have chosen a specific provider, look up the dns_provider object from their answer.
        for dns in dns_providers:
            if dns.name == answer:
                answer_provider = dns
                break
            else:
                answer_provider = None
            #end else:
        #end for dns in dns_providers:
    #end else:
    
    return answer_provider
    
# def choose_dns_provider():

########################
##  Config Functions  ##
########################

def install_dnsmasq_config(dns_provider, interface : str):
    """Reads the template dnsmasq conf file, makes replacements, and outputs to the final location."""
    
    dnsmasq_conf_in  = os.path.join(pyhole.share_dir, 'conf/dnsmasq/01-pyhole.conf')
    dnsmasq_conf_out = '/etc/dnsmasq.d/01-pyhole.conf'
    
    # Generate all "server = x.x.x.x" lines
    DNSSERVERS = ""
    
    for s in dns_provider.servers:
        DNSSERVERS += "server={0}\n".format(s)
    #end for s in dns_provider.servers:
    
    # The strings we are replacing.
    replacements = {
        '@DNSSERVERS@' : DNSSERVERS,
        '@INT@'        : interface
    }
    
    copy_and_replace(dnsmasq_conf_in, dnsmasq_conf_out, replacements)
    
#end def install_dnsmasq_config(dns_provider, interface : str):

def create_htpasswd_file(password):
    htpasswd_file  = os.path.join(pyhole.config_dir, 'htpasswd')
    htpasswd_cmd = 'htpasswd -cb "{0}" pi-hole "{1}"'.format(htpasswd_file, password)
    os.system( htpasswd_cmd )
    
    return htpasswd_file
#end def create_htpasswd_file(password):

def install_webserver_config(web_server, interface : str, ipv4_address, web_root_pyhole, web_root_admin, htpasswd_file):
    
    # The strings we are replacing.
    replacements = {
        '@IPv4addr@'        : ipv4_address['addr'],
        '@INT@'             : interface,
        '@web_root_pyhole@' : web_root_pyhole,
        '@web_root_admin@'  : web_root_admin,
        '@htpasswd_file@'   : htpasswd_file
    }
    
    if web_server == "lighttpd":
        lighttpd_conf_in = os.path.join(pyhole.share_dir, 'conf/lighttpd/lighttpd.conf')
        lighttpd_conf_out = '/etc/lighttpd/lighttpd.conf'
        
        # Backup the original file.
        lighttpd_conf_out_bak = lighttpd_conf_out + ".orig"
        shutil.move(lighttpd_conf_out, lighttpd_conf_out_bak)
        
        copy_and_replace(lighttpd_conf_in, lighttpd_conf_out, replacements)
    elif web_server == "apache":
        apache_pyhole_in = os.path.join(pyhole.share_dir, 'conf/apache/pyhole.conf')
        apache_pyhole_out = '/etc/apache2/sites-available/pihole.conf'
        
        copy_and_replace(apache_pyhole_in, apache_pyhole_out, replacements)
        
        apache_admin_in = os.path.join(pyhole.share_dir, 'conf/apache/pyhole-admin.conf')
        apache_admin_out = '/etc/apache2/sites-available/pihole-admin.conf'
        
        copy_and_replace(apache_admin_in, apache_admin_out, replacements)
    #end elif web_server == "apache":
    
#end def install_webserver_config(web_server):

def install_webserver(web_root_pyhole, web_root_admin):
    pyhole_in  = os.path.join(pyhole.share_dir, 'www/pyhole/pyhole'     )
    pyhole_out = os.path.join(web_root_pyhole , 'pyhole'                )
    admin_in   = os.path.join(pyhole.share_dir, 'www/pyhole-admin/admin')
    admin_out  = os.path.join(web_root_admin  , 'admin'                 )
    
    # copytree requires the destination does not exist.
    # So we try to delete our destinations first.
    
    try: shutil.rmtree(pyhole_out)
    except: pass
    
    try: shutil.rmtree(admin_out)
    except: pass
    
    # Copy folder contents to new folder.
    shutil.copytree(pyhole_in, pyhole_out)
    shutil.copytree(admin_in , admin_out )
    
#end def install_webserver(web_root_pyhole, web_root_admin):

def install_sudoers_file():
    sudoers_file_in  = os.path.join(pyhole.share_dir, 'conf/sudoers.d/pyhole')
    sudoers_file_out = '/etc/sudoers.d/pyhole'
    
    # Mode 440 as in /etc/sudoers.d/README
    shutil.copy(sudoers_file_in, sudoers_file_out)
    os.chmod(sudoers_file_out, mode = 0o440 )
#end def install_sudoers_file():

def create_pyhole_user():
    # We are OK to just go ahead and run useradd even if the user already exists.
    # A message will display but this is not a problem.
    # For reference, the exit code is 9 when the user already exists.
    os.system("useradd --system --shell /usr/sbin/nologon pyhole")
#end def create_pyhole_user:

def set_dir_permissions():
    # /var/lib/pyhole needs to have group owner pyhole
    # and be group writeable.
    shutil.chown(pyhole.var_dir, user = 'root', group = 'pyhole')
    os.chmod(pyhole.var_dir, mode = 0o775 )
    
    # That's it.
    # /etc/pyhole should root writeable like anything else in /etc.
    # Ditto with /usr/share/pyhole.
#end def set_dir_permissions():

########################
###   Gather Info    ###
########################

# Gather information from the user, but don't make any changes.

# Welcome!
show_welcome_message()

########################
### Web Server

# Choose a web server and web root paths.
web_server = choose_web_server()
web_root_pyhole, web_root_admin = choose_web_roots()

if web_server == 'Manual':
    password_message = """The pyhole admin interface needs to be protected from unauthorised access.  You have chosen for Pi-Hole to install to a manually configured web server, so please make sure to configure authentication, for example with a username and password."""
    
    d.msgbox(password_message)
    
    web_password_set = False
else:
    web_password = choose_webserver_password()
    web_password_set = True
#end else:

########################
### IP addresses

ip_message = """As pyhole will be running a DNS server, it is essential that your internal IP address is static.  A dynamic internal IP is not suitable.  (A DHCP reservation may work in some situations but is not recommended.)

pyhole can set a static IP address for you, though if you know how to set one yourself within Linux it is recommended you configure this outside of pyhole.

Furthermore, if you are already running another web server, it is strongly recommended to configure a SECOND static IP address for pyhole.  This is outside the scope of pyhole-config.

(Note that your external IP does not matter - it can be static, dynamic, whatever.)
"""

d.msgbox(ip_message)

# Choose an interface, whether using IPv4 and/or IPv6, and addresses.
interface = choose_interface()

protocols = choose_ipv4_ipv6()

use_ipv4 = 'IPv4' in protocols
use_ipv6 = 'IPv6' in protocols

if use_ipv4:
    ipv4_address = choose_ipv4_address(interface)
    ipv4_reconfigure = choose_ipv4_reconfigure(interface, ipv4_address)
    
    if ipv4_reconfigure == "Configure":
        addr, netmask, gateway = choose_ipv4_new_static(interface, ipv4_address)
        # IPv4 address configuration goes here
    #end if ipv4_reconfigure == "Configure":
#end if 'IPv4' in protocols:

if use_ipv6:
    ipv6_address = choose_ipv6_address(interface)
#end if 'IPv6' in protocols:

########################
### DNS Servers

# Choose upstream DNS servers
dns_provider = choose_dns_provider()


########################
###     Configure    ###
########################

# Start configuring!

# Write pyhole conf file.

pyhole.config['Network']                = {}
pyhole.config['Network']['interface']   = interface
pyhole.config['Network']['use_ipv4']    = str(use_ipv4)
pyhole.config['Network']['use_ipv6']    = str(use_ipv6)
pyhole.config['Network']['ipv4_addr']   = ipv4_address['addr']

pyhole.config['WebServer']                      = {}
pyhole.config['WebServer']['web_server']        = web_server
pyhole.config['WebServer']['web_root_pyhole']   = web_root_pyhole
pyhole.config['WebServer']['web_root_admin']    = web_root_admin

pyhole.write_config()

# Write / copy config.

install_dnsmasq_config(dns_provider, interface)
install_sudoers_file()
htpasswd_file = create_htpasswd_file(web_password)

install_webserver_config(web_server, interface, ipv4_address, web_root_pyhole, web_root_admin, htpasswd_file)
install_webserver(web_root_pyhole, web_root_admin)

# Create pyhole user and set permissions.

create_pyhole_user()
set_dir_permissions()

